<!doctype html>
<html lang="zh-Hans" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.3.1">
<title data-rh="true">浏览器环境中渲染表格 | yuanxin</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://yuanxin518.github.io/blog/2023/9/13/ 浏览器环境中渲染表格"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" name="keywords" content="前端 react webpack redux git"><meta data-rh="true" property="og:title" content="浏览器环境中渲染表格 | yuanxin"><meta data-rh="true" name="description" content="在网页中渲染一个表格，基本上是这两种方法，一是采用原生的table标签，二是通过div标签+contenteditable属性来。"><meta data-rh="true" property="og:description" content="在网页中渲染一个表格，基本上是这两种方法，一是采用原生的table标签，二是通过div标签+contenteditable属性来。"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2023-09-13T00:00:00.000Z"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://yuanxin518.github.io/blog/2023/9/13/ 浏览器环境中渲染表格"><link data-rh="true" rel="alternate" href="https://yuanxin518.github.io/blog/2023/9/13/ 浏览器环境中渲染表格" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://yuanxin518.github.io/blog/2023/9/13/ 浏览器环境中渲染表格" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://58UO1EPKN3-dsn.algolia.net" crossorigin="anonymous"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="yuanxin RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="yuanxin Atom Feed">



<link rel="search" type="application/opensearchdescription+xml" title="yuanxin" href="/opensearch.xml"><link rel="stylesheet" href="/assets/css/styles.0869f753.css">
<link rel="preload" href="/assets/js/runtime~main.0c89c040.js" as="script">
<link rel="preload" href="/assets/js/main.cb49f525.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><b class="navbar__title text--truncate">Yuanxin</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">博客</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/yuanxin518" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Github</a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">搜索</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="最近博文导航"><div class="sidebarItemTitle_pO2u margin-bottom--md">所有内容</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2024/08/15/ 树相关函数的实现和ts封装"> 树相关函数的实现和ts封装</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2024/1/9/ pnpm安装，报错本地服务异常">pnpm 安装，报错本地服务异常</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2023/12/23/ monorepo下匹配不到ts的问题">2023-12-23 monorepo下匹配不到ts的问题</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2023/10/21/ Ant Deisgn模态框内嵌Form的初始值不更新">2023-10-21 Ant Deisgn 模态框内嵌 Form 的初始值不更新</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2023/10/10/ netlify部署警告导致build中断">netlify 部署警告导致 build 中断</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2023/10/9/ contentEditable让光标到输入框最后">contentEditable 的 div 元素，让聚焦时光标到最后</a></li><li class="sidebarItem__DBe"><a aria-current="page" class="sidebarItemLink_mo7H sidebarItemLinkActive_I1ZP" href="/blog/2023/9/13/ 浏览器环境中渲染表格"> 浏览器环境中渲染表格</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2023/9/1/ passing props 阻止styled-components的props绑定到原生dom上"> passing props 阻止styled-components的props绑定到原生dom上</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2023/8/30/ 动态生成自定义svg的解决方法"> 动态生成自定义svg的解决方法</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2023/7/20/ github pr和变基合并提交记录"> github pr和变基合并提交记录</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2023/7/18/ git本地管理到github的关联"> git本地管理到github的关联</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2023/7/15/ 页面大量dom的优化"> 页面大量dom的优化</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2023/4/27/ webpack chunk与runtime优化"> webpack chunk与runtime优化</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="title_f1Hy" itemprop="headline"> 浏览器环境中渲染表格</h1><div class="container_mt6G margin-vert--md"><time datetime="2023-09-13T00:00:00.000Z" itemprop="datePublished">2023年9月13日</time> · <!-- -->阅读需 14 分钟</div></header><div id="post-content" class="markdown" itemprop="articleBody"><p>在网页中渲染一个表格，基本上是这两种方法，一是采用原生的<strong>table标签</strong>，二是通过<strong>div标签+contenteditable属性</strong>来。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1-原生table标签和div标签的对比">1. 原生table标签和div标签的对比<a href="#1-原生table标签和div标签的对比" class="hash-link" aria-label="1. 原生table标签和div标签的对比的直接链接" title="1. 原生table标签和div标签的对比的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="table标签">table标签<a href="#table标签" class="hash-link" aria-label="table标签的直接链接" title="table标签的直接链接">​</a></h3><p>原生table标签能够很方便的去渲染出表格，只需要按照table标签的规范来填充数据。</p><p>如果我们要修改它的样式，要通过css来修改每一个部分对应的标签的css属性。例如<code>th</code>,<code>td</code>,<code>td</code>标签等等。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="div实现div代指其他标签">div实现（div代指其他标签）<a href="#div实现div代指其他标签" class="hash-link" aria-label="div实现（div代指其他标签）的直接链接" title="div实现（div代指其他标签）的直接链接">​</a></h3><p>俗话说，万物皆可div。只要我们渲染逻辑写的缜密，我们仍然可以去通过div去实现一套视觉友好，甚至能够符合html5的无障碍规范等等的表格组件出来。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="如何选择">如何选择<a href="#如何选择" class="hash-link" aria-label="如何选择的直接链接" title="如何选择的直接链接">​</a></h3><p>用table毕竟是已经封装好的原生的组件，所以难免会遇到一些不好解决的，具有局限性的配置等。就比如说，表格中每一个元素的边框，会产生一些重叠，导致内层的边框比外层的边框粗，但是我们可以通过table提供的<code>border-collapse</code>去实现内外边框粗细一致。还有我们想定制这个表格的元素的时候，会发现仍然有很多局限，因为每个元素都已经被规范应该是什么样的位置等，所以想要在元素中嵌入一些自定义的元素，就要花更多的事件去考虑需要怎么嵌入。  </p><p>上述所说的问题在很多场景下没有大碍，但是在一些组件库中，或者在高度定制的表格项目中，我们用原生的table标签并不有利。所以在很多项目例如<code>腾讯表格</code>，没有用原生的table表格来实现，而是通过div等标签来实现的。</p><p>那么用div能有什么好处？首先上述原生table显露出来的一个问题就是，我们的渲染逻辑都局限在了table标签的规范中去了，所有的元素都被规范局限了渲染逻辑。很方便的渲染出一个表格，但问题总是在后期遇到。那么我们何不去封装一套更好的表格渲染逻辑，或者说是一套符合高度自定义的场景，同样暴露出和原生table标签所一致的api等等，但此基础上还暴露出了更多的自定义的api，就像所说的嵌入元素等的api。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2-div的渲染设计">2. div的渲染设计<a href="#2-div的渲染设计" class="hash-link" aria-label="2. div的渲染设计的直接链接" title="2. div的渲染设计的直接链接">​</a></h2><p>要实现一个表格，最终要的是渲染出表格的框架，其次就是实现表格的内容编辑的功能，后面就是对单元格的一些操作，以及适应屏幕的逻辑等。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1-生成驱动视图的数据">1. 生成驱动视图的数据<a href="#1-生成驱动视图的数据" class="hash-link" aria-label="1. 生成驱动视图的数据的直接链接" title="1. 生成驱动视图的数据的直接链接">​</a></h3><p>表格，首先最容易想到的是用二维数组来实现，二维数组的第一维数据来渲染每一行，将每一行都渲染出来就形成了一个表格。</p><p>arr: <code>[[ ,A,B,C],[1,A1,B1,C1],[2,A2,B2,C2]]</code></p><table><thead><tr><th></th><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr><td>1</td><td>A1</td><td>B1</td><td>C1</td></tr><tr><td>2</td><td>A2</td><td>B2</td><td>C2</td></tr></tbody></table><p>就像上面这样对应起来，arr是最原始的渲染数组，其中包括了表头的数据。在arr<!-- -->[0]<!-- -->中是<code>[,A,B,C..]</code>，第一个是<code>undefined</code>，所以在后面的逻辑中渲染出来的是空白。<em>是否一个表格数据应该包含表头数据？我认为最原始数组最好保留所有的数据，在后面的渲染中进行逻辑排除处理是一个比较好的做法。</em></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2-根据数据来渲染表格">2. 根据数据来渲染表格<a href="#2-根据数据来渲染表格" class="hash-link" aria-label="2. 根据数据来渲染表格的直接链接" title="2. 根据数据来渲染表格的直接链接">​</a></h3><p>数据已经被分为了数组的每一项，那么我们把每一维当行，每一维中的每一项当列即可。那么通过2层二维渲染就可以成功渲染出来。<strong>其中需要做的重要处理就是对空数据的处理，如果为空的时候我们不能单纯的不渲染这个元素，否则这个单元格的宽度和高度不会被撑起来。我们需要对它做标记，在css的处理上要针对性处理。</strong></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="3-编写表格的样式">3. 编写表格的样式<a href="#3-编写表格的样式" class="hash-link" aria-label="3. 编写表格的样式的直接链接" title="3. 编写表格的样式的直接链接">​</a></h3><p>如果我们单独为每个单元格都编写上下左右的边框，那就会出现边框重叠的问题，内部的宽度比外围的宽度粗，并且表格也出现了不对其的问题。</p><p>要解决边框粗细一致，在渲染的时候采取一定的措施，就是<strong>按一个方向去渲染表格的边框</strong>。比如说，只渲染表格的右边和下边的边框，最后渲染出来的结果就是没有任何的单元格边框被重叠，但是第一列和第一行的左边框或上边框没有被渲染出来。所以这个时候我们针对第一行和第一列，额外对它们设置左边和上边的边框的渲染。这样就达成了一个边框粗细一致的表格。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="35-边框渲染出现的问题">3.5 边框渲染出现的问题**<a href="#35-边框渲染出现的问题" class="hash-link" aria-label="3.5 边框渲染出现的问题**的直接链接" title="3.5 边框渲染出现的问题**的直接链接">​</a></h3><p>通过给每一个div单元格设置边框，因为<strong>第一行和第一列的边框渲染边框逻辑不一致，所以这些盒子在内容上的尺寸不一致。</strong>例如默认情况下每一个单元格的宽度是100px，高度是30px，边框宽度为1px，那么<strong>大多数单元格边框渲染后的尺寸变成了99px和29px，而第一行和第一列变成了98px和28px。</strong>或许你会说，<code>box-sizing</code>可以让它们的内容尺寸保持一致，但是内容保持一致了盒子总体宽度还一致吗？显然不一致。 那么为了解决这一个问题，我运用到了<strong>伪元素来渲染表格边框。</strong></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="4-表格样式改良---伪元素">4. 表格样式改良 - 伪元素<a href="#4-表格样式改良---伪元素" class="hash-link" aria-label="4. 表格样式改良 - 伪元素的直接链接" title="4. 表格样式改良 - 伪元素的直接链接">​</a></h3><p>伪元素的一个特点就是不会占据文档流位置，不会对盒子产生任何的宽高上的形变等。用伪元素之后，<strong>我们的表格就可以简单的渲染成100px，30px的尺寸，而不考虑宽度。这时候这些单元格没有任何的边框，接下来要借助伪元素来渲染边框。</strong>通过伪元素渲染边框就可以简单的设置100%宽高来让伪元素铺满100px和30px的div，然后同样是按一个方向来渲染之前的表格，但是这一次的结果是渲染完表格之后，<strong>所有单元格的尺寸仍然是100px和30px。</strong></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5-实现内容的编辑">5. 实现内容的编辑**<a href="#5-实现内容的编辑" class="hash-link" aria-label="5. 实现内容的编辑**的直接链接" title="5. 实现内容的编辑**的直接链接">​</a></h3><p>在div中要实现内容的编辑，我们就需要借助<code>contenteditable</code>属性，设置了这个属性之后的div在被点击之后就会变成一个输入框，输入内容。</p><p>这个属性的编辑在生效后，我们要实现让编辑的最新的内容写入到state中，然后触发重新渲染。梳理一下完整的编辑逻辑就是：</p><p><strong>1. 正常通过state最原始的空数组渲染出空白的单元格</strong></p><p><strong>2. 单元格被点击，编辑内容</strong></p><p><strong>3. 单元格上面的input事件被触发，回调函数中实现获取最新输入的内容，然后更新state</strong></p><p><strong>4. state中对应单元格索引的数据改变，最新渲染单元格中内容改变</strong></p><hr><p>看起来渲染逻辑没有问题，但是在第3点到第4点，也就是重新渲染的过程中，如果我们输入框一直在触发输入，渲染也在被一直重新触发，那么是不是会出现一个问题，<strong>就是我们输入的内容因为重新渲染而消失，导致数据丢失等？ 而我出现的问题实际上是出现每次输入光标都会跑到最前面</strong></p><p>为了解决这样的一个问题，就要<strong>让输入和渲染内容的容器被区分开</strong>，但是让几个div叠加到单元格上，点击单元格实际触发的是另外的一个输入框，但是这样单元格会变得层级比较复杂，可能会更容易出现bug。我就想<strong>能不能用防抖来实现，也就是输入内容的时候并不立刻去重新渲染，而是等待一段时间。</strong>事实上，并不能行得通，因为如果在输入阶段停下来引起了防抖函数的执行，那么仍然会重新执行，光标仍然会跑到最前面。 </p><p>参考了一些单元格的产品，我觉得在这上面做一个妥协也是行得通的，就是在<strong>单元格进行失焦的时候再来重新渲染。</strong>在后期也可以在数据的保护上更下功夫。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="6-实现单元格选中的高亮边框">6. 实现单元格选中的高亮边框<a href="#6-实现单元格选中的高亮边框" class="hash-link" aria-label="6. 实现单元格选中的高亮边框的直接链接" title="6. 实现单元格选中的高亮边框的直接链接">​</a></h3><p>实现高亮边框，修改单元格的伪元素的边框不太现实，这样也可能造成更多的元素的属性的修改，对性能可能不太有利。所以最好是单独用一个div来实现，而表格的尺寸和位置都通过元素的计算来实现。 比如我点击了一个row索引为10，column索引为8的单元格，那么<strong>根据这一个单元格索引结合每一个单元格的尺寸配置数据，来计算出单元格需要偏移多少个像素，宽度高度是多少。</strong>选中多个单元格也是如此，无非就是多计算几个单元格的尺寸。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="7-实现单元格的伸缩和虚拟列表适应全屏等">7. 实现单元格的伸缩和虚拟列表适应全屏等<a href="#7-实现单元格的伸缩和虚拟列表适应全屏等" class="hash-link" aria-label="7. 实现单元格的伸缩和虚拟列表适应全屏等的直接链接" title="7. 实现单元格的伸缩和虚拟列表适应全屏等的直接链接">​</a></h3><p>上面已经说明了这个表格是如何通过数据去驱动整个视图的渲染的，那么要做单元格的伸缩等，从css的渲染上入手即可。</p><p>根据一个配置，计算出这个配置对哪些索引的表格尺寸进行了修改，然后在注入css属性的时候根据这个计算进行动态的改变，我觉得这是一个比较开放的功能，没有很多需要特别强调的点，如果要进行优化性能，无非是针对大量数据的场景下表格尺寸计算的算法速度和空间占用等。</p><p>虚拟列表这些，也都是那样的方案，针对场景做做调整即可。</p></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="博文分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/2023/10/9/ contentEditable让光标到输入框最后"><div class="pagination-nav__sublabel">较新一篇</div><div class="pagination-nav__label">contentEditable 的 div 元素，让聚焦时光标到最后</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/2023/9/1/ passing props 阻止styled-components的props绑定到原生dom上"><div class="pagination-nav__sublabel">较旧一篇</div><div class="pagination-nav__label"> passing props 阻止styled-components的props绑定到原生dom上</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#1-原生table标签和div标签的对比" class="table-of-contents__link toc-highlight">1. 原生table标签和div标签的对比</a><ul><li><a href="#table标签" class="table-of-contents__link toc-highlight">table标签</a></li><li><a href="#div实现div代指其他标签" class="table-of-contents__link toc-highlight">div实现（div代指其他标签）</a></li><li><a href="#如何选择" class="table-of-contents__link toc-highlight">如何选择</a></li></ul></li><li><a href="#2-div的渲染设计" class="table-of-contents__link toc-highlight">2. div的渲染设计</a><ul><li><a href="#1-生成驱动视图的数据" class="table-of-contents__link toc-highlight">1. 生成驱动视图的数据</a></li><li><a href="#2-根据数据来渲染表格" class="table-of-contents__link toc-highlight">2. 根据数据来渲染表格</a></li><li><a href="#3-编写表格的样式" class="table-of-contents__link toc-highlight">3. 编写表格的样式</a></li><li><a href="#35-边框渲染出现的问题" class="table-of-contents__link toc-highlight">3.5 边框渲染出现的问题**</a></li><li><a href="#4-表格样式改良---伪元素" class="table-of-contents__link toc-highlight">4. 表格样式改良 - 伪元素</a></li><li><a href="#5-实现内容的编辑" class="table-of-contents__link toc-highlight">5. 实现内容的编辑**</a></li><li><a href="#6-实现单元格选中的高亮边框" class="table-of-contents__link toc-highlight">6. 实现单元格选中的高亮边框</a></li><li><a href="#7-实现单元格的伸缩和虚拟列表适应全屏等" class="table-of-contents__link toc-highlight">7. 实现单元格的伸缩和虚拟列表适应全屏等</a></li></ul></li></ul></div></div></div></div></div></div>
<script src="/assets/js/runtime~main.0c89c040.js"></script>
<script src="/assets/js/main.cb49f525.js"></script>
</body>
</html>